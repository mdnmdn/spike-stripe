# SQLc integration (SQLite local or Turso)

This repo ships with a minimal, production-friendly SQLc setup and migrations that create only one table: `cache (key TEXT PRIMARY KEY, value TEXT NOT NULL)`.

You can run locally against a SQLite file, or connect to Turso (LibSQL) when an environment variable is present.

## What’s included

- sqlc config at `sqlc.yaml` generating Go into `internal/db`
- migrations in `db/migrations` (only the `cache` table)
- queries in `db/queries`
- pure-Go SQLite driver (no CGO) via `modernc.org/sqlite`
- optional Turso connection via `github.com/tursodatabase/libsql-client-go/libsql`
- tiny migration runner at `cmd/migrate`

## Install and generate

1) Install sqlc

```bash
go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest
```

2) Generate code

```bash
sqlc generate
```

This creates the generated package under `internal/db`.

## Files and configuration

- `sqlc.yaml`
  ```yaml
  version: "2"
  sql:
    - engine: "sqlite"
      schema: "./db/migrations"
      queries: "./db/queries"
      gen:
        go:
          package: "db"
          out: "./internal/db"
          sql_package: "database/sql"
          emit_json_tags: true
          emit_prepared_queries: true
          emit_interface: true
          emit_empty_slices: true
  ```

- `db/migrations/0001_cache.sql`
  ```sql
  -- Create a simple key/value cache table
  CREATE TABLE IF NOT EXISTS cache (
    key   TEXT PRIMARY KEY,
    value TEXT NOT NULL
  );
  ```

- `db/queries/cache.sql`
  ```sql
  -- name: GetCacheValue :one
  SELECT value FROM cache WHERE key = ? LIMIT 1;

  -- name: SetCacheValue :exec
  INSERT INTO cache (key, value)
  VALUES (?, ?)
  ON CONFLICT(key) DO UPDATE SET value=excluded.value;

  -- name: DeleteCacheKey :exec
  DELETE FROM cache WHERE key = ?;

  -- name: ListCache :many
  SELECT key, value FROM cache ORDER BY key ASC;
  ```

## Database connection

Helpers live in `internal/db/connection.go`.

Selection logic:
- If `TURSO_DATABASE_URL` is set, connect to Turso using the libsql client.
- Otherwise open a local SQLite database file.

Environment variables:
- `DB_PATH`: optional path to local SQLite file; default: `_data/db-spike-strip.sqlite3`
- `TURSO_DATABASE_URL`: Turso connection URL (libsql://...)
- `TURSO_AUTH_TOKEN`: Turso auth token (optional if DB is public)

The SQLite driver used is `modernc.org/sqlite` (driver name `sqlite`), so no CGO is required.

## Migrations

A tiny migration runner is included at `cmd/migrate`. It applies all `.sql` files in `db/migrations` in lexical order.

Run locally (SQLite by default at `_data/db-spike-strip.sqlite3`):

```bash
# optional: override local db path
export DB_PATH=_data/db-spike-strip.sqlite3

# apply migrations
go run cmd/migrate/main.go
```

Run against Turso:

```bash
export TURSO_DATABASE_URL=libsql://your-db-xxxx.turso.io
export TURSO_AUTH_TOKEN=your-token

go run cmd/migrate/main.go
```

## Using the generated code

After `sqlc generate`, you can use the generated `Queries` type with a `*sql.DB` from `db.NewConnection()`:

```go
import (
  "context"
  sqldb "database/sql"
  mydb "stripe-go-spike/internal/db"
)

func example() error {
  d, err := mydb.NewConnection()
  if err != nil { return err }
  defer d.Close()

  q := mydb.New(d) // generated by sqlc
  ctx := context.Background()

  if err := q.SetCacheValue(ctx, "hello", "world"); err != nil {
    return err
  }
  val, err := q.GetCacheValue(ctx, "hello")
  _ = val
  return err
}
```

## Notes

- Only the `cache` table is provided; no Stripe-related tables are created.
- The HTTP API is unaffected by this optional database integration.
- You can integrate migrations at server startup if you prefer; they’re a separate command here.
